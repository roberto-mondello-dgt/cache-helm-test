name: Deploy (sub) with Cache

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to run apply against'
        required: true
        type: string
      timeout_seconds:
        description: 'Kubectl apply wait timeout in seconds for Deployments'
        required: true
        type: number

defaults:
  run:
    shell: bash

env:
  SCRIPTS_FOLDER: "./interop-infra-commons/scripts/helm"

jobs:
  workflow_setup:
    name: Setup steps
    runs-on: [ self-hosted, "run_id:${{ inputs.environment }}-${{ github.run_id }}" ]
    environment: ${{ inputs.environment }}
    env:
      TARGET_ENVIRONMENT: ${{ inputs.environment }}
    outputs:
      microservices: ${{ steps.set-outputs.outputs.microservices }}
      cronjobs: ${{ steps.set-outputs.outputs.cronjobs }}
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v3
      - id: set-outputs
        run: |
          echo "microservices=$(find microservices -type f -path \"*/$TARGET_ENVIRONMENT/values.yaml\" -exec dirname {} \; | awk -F'/' '{print $2}' | jq -R -s -c 'split("\n")[:-1]')" >> "$GITHUB_OUTPUT"
          echo "cronjobs=$(find jobs -type f -path \"*/$TARGET_ENVIRONMENT/values.yaml\" -exec dirname {} \; | awk -F'/' '{print $2}' | jq -R -s -c 'split("\n")[:-1]')" >> "$GITHUB_OUTPUT"

  deploy_common_configmaps:
    name: Deploy Common Configmaps
    needs: [ workflow_setup ]
    runs-on: [ self-hosted, "run_id:${{ inputs.environment }}-${{ github.run_id }}" ]
    environment: ${{ inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Update Kubeconfig
        run: |
          set -euo pipefail
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME }}
      - name: Apply commons configmaps
        run: |
          set -euo pipefail
          commons_configmaps_path="commons/${{ inputs.environment }}/configmaps"
          if [[ -n "$(ls -A $commons_configmaps_path)" ]]; then
            for f in $commons_configmaps_path/*; do
              kubectl apply -f $f
            done
          fi

  deploy_ms:
    name: Deploy Microservice ${{ matrix.microservice }}
    needs: [ workflow_setup, deploy_common_configmaps ]
    if: ${{ ! contains(needs.workflow_setup.outputs.microservices, '[]') }}
    runs-on: [ self-hosted, "run_id:${{ inputs.environment }}-${{ github.run_id }}" ]
    environment: ${{ inputs.environment }}
    strategy:
      matrix:
        microservice: ${{ fromJson(needs.workflow_setup.outputs.microservices) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Cache Docker Image
        id: cache-image-ms
        uses: actions/cache@v3
        with:
          path: /tmp/image-cache-ms
          key: ${{ runner.os }}-image-${{ inputs.environment }}-${{ matrix.microservice }}

      - name: Load Cached Image
        if: steps.cache-image-ms.outputs.cache-hit == 'true'
        run: |
          for f in /tmp/image-cache-ms/*.tar; do docker load -i "$f"; done

      - name: Pull & Cache New Image
        if: steps.cache-image-ms.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/image-cache-ms
          IMG=$(yq e '.image.repository + ":" + .image.tag' "microservices/${{ matrix.microservice }}/Chart.yaml")
          docker pull "$IMG"
          docker save "$IMG" -o "/tmp/image-cache-ms/${{ matrix.microservice }}.tar"

      - name: Deploy
        run: |
          echo "deploy issued"

  deploy_cj:
    name: Deploy Cronjob ${{ matrix.cronjob }}
    needs: [ workflow_setup, deploy_common_configmaps ]
    if: ${{ ! contains(needs.workflow_setup.outputs.cronjobs, '[]') }}
    runs-on: [ self-hosted, "run_id:${{ inputs.environment }}-${{ github.run_id }}" ]
    environment: ${{ inputs.environment }}
    strategy:
      matrix:
        cronjob: ${{ fromJson(needs.workflow_setup.outputs.cronjobs) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Cache Docker Image
        id: cache-image-cj
        uses: actions/cache@v3
        with:
          path: /tmp/image-cache-cj
          key: ${{ runner.os }}-image-${{ inputs.environment }}-cj-${{ matrix.cronjob }}

      - name: Load Cached Cronjob Image
        if: steps.cache-image-cj.outputs.cache-hit == 'true'
        run: |
          for f in /tmp/image-cache-cj/*.tar; do docker load -i "$f"; done

      - name: Pull & Cache New Cronjob Image
        if: steps.cache-image-cj.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/image-cache-cj
          IMG=$(yq e '.image.repository + ":" + .image.tag' "jobs/${{ matrix.cronjob }}/Chart.yaml")
          docker pull "$IMG"
          docker save "$IMG" -o "/tmp/image-cache-cj/${{ matrix.cronjob }}.tar"

      - name: Deploy
        run: |
          echo "deploy issued"
